#  Copyright (c) 2012
#  by authors as mentioned on:
#  https://github.com/lkastner/polymake_toric/wiki/Authors
#  
#  Project home:
#  https://github.com/lkastner/polymake_toric
#
#  For licensing we cite the original Polymake code:
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

###################################################
###################################################
###
###  object declarations
###
###################################################
###################################################
declare object CyclicQuotient : ToricVariety;

object CyclicQuotient {

   declare object VersalComponent;

}

###################################################
###################################################
###
###  CyclicQuotient properties
###
###################################################
###################################################
object CyclicQuotient {

   property N : Integer;

   property Q : Integer;
    
   property CONTINUED_FRACTION : Vector<Integer>;
   
   property DUAL_CONTINUED_FRACTION : Vector<Integer>;

   property VERSAL_COMPONENT : VersalComponent : multiple;
   
   property VERSAL_COMPONENTS : Matrix;

   property VERSAL_DEFORMATION : Ideal;
}

###################################################
###################################################
###
###  VersalComponent properties
###
###################################################
###################################################
object CyclicQuotient {

   object VersalComponent {

      property CONTINUED_FRACTION : Vector<Integer>;

      property PYRAMID_LATTICE : Map<Vector<Integer>, Vector<Integer>>;

      property ALPHA_LATTICE : Map<Vector<Integer>, Vector<Integer>>;

      property TOTAL_SPACE : Ideal;

   }

}

###################################################
###################################################
###
###  CyclicQuotient rules
###
###################################################
###################################################
object CyclicQuotient {

   rule VERSAL_DEFORMATION : DUAL_CONTINUED_FRACTION {
      my $a = $this->DUAL_CONTINUED_FRACTION;
      my $i = 0;
      my $j = 0;
      my $k = 0;
      my $e = $a->dim+2;
      my @x = ();
      my @s = ();
      my @t = ();
      for($i=0; $i<$e; $i++){
         push @x, "x_".$i;
      }
      for($i=1; $i<$e-1; $i++){
         for($j=1; $j<$a->[$i-1]; $j++){
            push @s, "s_{".$i.",".$j."}";
         }
      }
      for($i=2; $i<$e-2; $i++){
         push @t, "t_".$i;
      }
      my $xnum = @x;
      my $snum = @s;
      my $tnum = @t;
      my $r = new Ring(@x, @s, @t);
      print $r->variables."\n";
   }

   # Computing the continued fractions corresponding to the components
   # of the versal base space according to the description given in
   # Stevens - On the Components[...].
   rule VERSAL_COMPONENTS : DUAL_CONTINUED_FRACTION {
      my $dcf = $this->DUAL_CONTINUED_FRACTION;
      $dcf = new Vector<Rational>($dcf);
      my $ineq = ($dcf | -unit_matrix($dcf->dim));
      $ineq = $ineq/(-ones_vector($dcf->dim) | unit_matrix($dcf->dim));
      # print $ineq;
      my $p = new Polytope(INEQUALITIES=>$ineq);
      my $candidates = $p->LATTICE_POINTS->minor(All, ~[0]);
      my @result = grep{
         my $v = christophersen_alpha($_);
         my @v= @$v;
         (pop @v) == 0
      }@{$candidates};
      # print @result;
      $this->VERSAL_COMPONENTS = new Matrix(@result);
   }

   rule N, Q : DUAL_CONTINUED_FRACTION {
      my $check = cf2rational($this->DUAL_CONTINUED_FRACTION);
      $this->N = new Integer(numerator($check));
      $this->Q = new Integer(numerator($check) - denominator($check));
   }

   rule DUAL_CONTINUED_FRACTION : N, Q {
      my $check = new Rational($this->N, ($this->N)-($this->Q));
      $this->DUAL_CONTINUED_FRACTION = rational2cf($check);
   }

   rule RAYS : N, Q {
      $this->RAYS = new Matrix([1,0],[-$this->Q, $this->N]);
   }

   rule MAXIMAL_CONES : {
      $this->MAXIMAL_CONES = [[0, 1]];
   }

   rule CONTINUED_FRACTION : N, Q {
      my $check = new Rational($this->N, $this->Q);
      # print $check."\n";
      $this->CONTINUED_FRACTION = rational2cf($check);
   }

   rule N, Q : CONTINUED_FRACTION {
      my $check = cf2rational($this->CONTINUED_FRACTION);
      $this->N = new Integer(numerator($check));
      $this->Q = new Integer(denominator($check));
   }
}

###################################################
###################################################
###
###  VersalComponent rules
###
###################################################
###################################################
object CyclicQuotient {

   rule VERSAL_COMPONENT.TOTAL_SPACE : DUAL_CONTINUED_FRACTION,\
         VERSAL_COMPONENT.CONTINUED_FRACTION,\
         VERSAL_COMPONENT.PYRAMID_LATTICE,\
         VERSAL_COMPONENT.ALPHA_LATTICE {
      # Funny stuff for generating the necessary variables.
      my $k = $this->VERSAL_COMPONENT->CONTINUED_FRACTION;
      my $klat = $this->VERSAL_COMPONENT->PYRAMID_LATTICE;
      my $a = $this->DUAL_CONTINUED_FRACTION;
      my $alpha = christophersen_alpha($k);
      my $alphalat = $this->VERSAL_COMPONENT->ALPHA_LATTICE;
      #print "k: ".$k."\na: ".$a."\nalpha: ".$alpha."\n";
      my $i = 0;
      my $l = 0;
      my @s = ();
      for($i = 1; $i<$a->dim-1; $i++){
         $alpha->[$i+1] == 1 ? (push @s, "s_".($i+1)) : 0;
      }
      my @t = ();
      for($i = 0; $i<$a->dim; $i++){
         for($l = 1; $l<$a->[$i]; $l++){
            push @t, "t_{".($i+1).",".$l."}";
         }
      }
      my @z = ();
      for($i = 0; $i<$alpha->dim; $i++){
         push @z, "z_".$i;
      }
      my @vars = (@t, @s, @z);
      my $r = new Ring(@vars);
      my @variables = $r->variables;
      my $unit = (@variables->[0])^0;
      print "unit: ".$unit."\n";
      #print @variables;
      #print "\n";
      my $snum = @s;
      my $tnum = @t;
      my $znum = @z;
      print $snum." ".$tnum." ".$znum."\n";
      @t = @variables[0..($tnum-1)];
      @s = @variables[$tnum..($tnum+$snum-1)];
      @z = @variables[($tnum+$snum)..($tnum+$snum+$znum-1)];
      #print @s;
      #print "\n";
      #print @t;
      #print "\n";
      #print @z;
      #print "\n";
      my $s = new Map<Integer, Monomial<Rational, Int>>;
      map{
         my ($i) = $_ =~ m/s\_(.*)/;
         $s->{new Int($i)} = $_;
      }@s;
      #print $s."\n";
      my $z = new Map<Integer, Monomial<Rational, Int>>;
      map{
         my ($i) = $_ =~ m/z\_(.*)/;
         $z->{new Int($i)} = $_;
      }@z;
      #print $z."\n";
      my $t = new Map<Vector<Integer>, Monomial<Rational, Int>>;
      map{
         my ($i,$l) = $_ =~ m/t\_\{(.*),(.*)\}/;
         $t->{new Vector<Integer>($i,$l)} = $_;
      }@t;
      for($i = 0; $i<$a->dim; $i++){
         $t->{new Vector<Integer>($i+1, $a->[$i])} = $unit;
      }
      # print $t."\n";
      my $y = new Map<Integer, Polynomial<Rational, Int>>;
      #$y->{0} = new Polynomial<Rational, Int>($z->{0});
      $y->{0} = 0 + $z->{0};
      $y->{1} = 0 + $z->{1};
      for($i = 2; $i<$a->dim; $i++){
         $alpha->[$i]==1 ? ($y->{$i} = $z->{$i}+$s->{$i}) : ($y->{$i} = 0 + $z->{$i});
      }
      $y->{$a->dim} = 0 + $z->{$a->dim};
      $y->{$a->dim+1} = 0 + $z->{$a->dim+1};
      # print $y."\n";
      my $r = 0;
      my $Z = new Map<Vector<Integer>, Polynomial<Rational, Int>>;
      for($i = 1; $i<=$a->dim; $i++){
         for($l=1; $l<=$a->[$i-1]; $l++){
            my $pos = new Vector<Integer>($i, $l);
            $Z->{$pos} = $unit-$unit;
            # print $Z->{$pos}."\n";
            for($r=new Int($a->[$i-1]); $r>=$l; $r--){
               my $tpos = new Vector<Integer>($i,$r);
               #print $tpos."\n";
               $Z->{$pos} += (($t->{$tpos})^(new Int($r)))*(($z->{$i})^(new Int($r-$l)));
            }
         }
      }
      print $Z."\n";
      my $X = new Map<Vector<Integer>, Polynomial<Rational, Int>>;
      my $j = 0;
      my $h = 0;
      for($i = 0; $i+1<=$a->dim; $i++){
         for($j = $i+2; $j-1<=$a->dim; $j++){
            for($h = $i+1; $h <= $j-1; $h++){
               my $pos = new Vector<Integer>($i,$j,$h);
               print $pos."\n";
               if(($h == 1) || ($h == $a->dim) || ($alpha->[$h] > 1)){
                  my $zpos = $klat->{$pos->slice(0,2)}->[$h-$i-1];
                  print "zpos: ".$zpos."\n";
                  print "Z: ".$Z->{new Vector<Integer>($h,$zpos)}."\n";
               } else {

               }
            }
         }
      }
   }
   
   object VersalComponent {

      rule CONTINUED_FRACTION : PYRAMID_LATTICE {
         $this->CONTINUED_FRACTION = $this->PYRAMID_LATTICE->{zero_vector<Integer>(2)};
      }

      rule ALPHA_LATTICE : PYRAMID_LATTICE {
         my $pyr_lat = new Map<Vector<Integer>, Vector<Integer>>($this->PYRAMID_LATTICE);
         my $result = new Map<Vector<Integer>, Vector<Integer>>();
         foreach my $key (keys %$pyr_lat){
            $result->{$key} = christophersen_alpha($pyr_lat->{$key});
         }
         $this->ALPHA_LATTICE = $result;
      }

      rule PYRAMID_LATTICE : CONTINUED_FRACTION {
         my $cf = new Vector<Integer>($this->CONTINUED_FRACTION);
         my $result = new Map<Vector<Integer>, Vector<Integer>>();
         my $i = 0;
         my $j = 0;
         my $n = $cf->dim;
         for($i = 0; $i < $n; $i++){
            my $copy = new Vector<Integer>($cf);
            # print $cf."\n";
            for($j = 0; $j < ($n-$i); $j++){
               $result->{new Vector<Integer>($j, $i)} = $copy;
               if($j < $n-$i-1){
                  $copy = christophersen_phi1($copy);
               }
            }
            if($i < $n-1){
               $cf = christophersen_phi2($cf);
            }
         }
         $this->PYRAMID_LATTICE = $result;
      }

   }

}

###################################################
###################################################
###
###  User functions
###
###################################################
###################################################
user_function assign_versal_components(CyclicQuotient){
   my($cq) = @_;
   my $vc = $cq->VERSAL_COMPONENTS;
   foreach my $v (@$vc){
      $cq->add("VERSAL_COMPONENT", CONTINUED_FRACTION=>$v);
   }
}

user_function pow(Polynomial<Rational, Int>, Integer){
   my($p, $k) =  @_;
   my $i = 0;
   my $result = new Polynomial<Rational, Int>($p);
   for($i = 0; $i<$k-1; $i++){
      $result*=$p;
   }
   return $result;
}

user_function christophersen_alpha(Vector<Integer>) {
   my($v) = @_;
   my @chain = @$v;
   my @result = ();
   my $a0 = 0;
   my $a1 = 1;
   my $a2 = 0;
   foreach my $entry (@chain){
      $a2 = $entry*$a1 - $a0;
      push @result, $a0;
      $a0 = $a1;
      $a1 = $a2;
   }
   push @result, $a0;
   push @result, $a1;
   return new Vector(@result);
}

user_function rational2cf(Rational){
   my($check) = @_;
   my @result = ();
   while($check != 0){
      push @result, new Integer(ceil($check));
      $check = ceil($check)- $check;
      $check = $check !=0 ? 1/$check : 0;
      # print $check."\n";
   }
   return new Vector(@result);
}

user_function cf2rational(Vector<Integer>){
   my($v) = @_;
   my @chain = @$v;
   my $check = new Rational(pop @chain);
   my $s = @chain;
   while($s > 0){
      $check = (new Rational(pop @chain)) - 1/$check;
      $s = @chain;
   }
   return $check;
}

user_function christophersen_phi1(Vector<Integer>){
   my($v) = @_;
   # print "phi1\n";
   # print "v: ".$v."\n";
   if($v->dim == 1) {die "Error: Vector too short.";}
   # if($v->dim == 2) {return zero_vector<Integer>(1);}
   my $alpha = christophersen_alpha($v);
   # print "a: ".$alpha."\n";
   my $i = $v->dim-1;
   while(($alpha->[$i]>0) && ($alpha->[$i] != 1)) {$i--;}
   # print "i: ".$i."\n";
   my $result = $v->slice(0,$v->dim-1);
   $result->[$i-1]--;
   # print "r: ".$result."\n\n";
   return $result;
}

user_function christophersen_phi2(Vector<Integer>){ 
   my($v) = @_;
   # print "phi2\n";
   # print "v: ".$v."\n";
   if($v->dim == 1) {die "Error: Vector too short.";}
   # if($v->dim == 2) {return zero_vector<Integer>(1);}
   my $alpha = christophersen_alpha($v);
   # print "a: ".$alpha."\n";
   my $i = 2;
   while(($alpha->[$i]>0) && ($alpha->[$i] != 1)) {$i++;}
   # print "i: ".$i."\n";
   my $result = $v->slice(1,$v->dim-1);
   $result->[$i-2]--;
   # print "r: ".$result."\n\n";
   return $result;
}
