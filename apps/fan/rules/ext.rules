#  Copyright (c) 2012
#  by authors as mentioned on:
#  https://github.com/lkastner/polymake_toric/wiki/Authors
#  
#  Project home:
#  https://github.com/lkastner/polymake_toric
#
#  For licensing we cite the original Polymake code:
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

object ToricVariety {

   user_method res(TDivisor){
      my $tv = $_[0];
      my $D = $_[1];
      print $D->COEFFICIENTS;
      my $c = new Cone(INPUT_RAYS=>$tv->RAYS);
      my $tvc = new Polytope(POINTS=>unit_vector($tv->AMBIENT_DIM+1,0)/(zero_vector($c->FACETS->rows)|$c->FACETS));
      print $tvc->VERTICES;
      my $Dgs = $D->SECTION_POLYTOPE;
      print "Vertices:\n", $Dgs->VERTICES;
      print "Inequalities:\n",$Dgs->INEQUALITIES;
      print "Product:\n",$Dgs->INEQUALITIES * transpose($Dgs->VERTICES);
      my $v = move_inside($tvc,$Dgs);
      my $Dp = lower_lattice_points($Dgs);
      $Dp = new Matrix(map($_+$v,@$Dp));
      $Dp = $Dp->minor(All,~[0]);
      print "New vertices:\n",$Dp,"\n";

      my $dual_cone = new Cone(INPUT_RAYS=>$c->FACETS);
      my $H = $dual_cone->HILBERT_BASIS;

      my $Dgen = new Matrix(map(find_positive_combination($_,$H,$c->RAYS),@$Dp));
      print "Check:\n",transpose($H)*transpose($Dgen);


      my $toric = $dual_cone->TORIC_IDEAL;
      # print "Toric ideal:\n",$toric;

      # Now all combinatorial information has been collected.
      # Generating input for Singular:
      print "LIB \"homolog.lib\";\n";
      print "ring R = 0,(x(0..",$H->rows-1,")),dp;\n";
      print "ideal toric = ";
      if($toric->rows == 0){
         print "0;\n";
      } else {
         foreach my $binomial (@$toric){
            print "1";
            for(my $i=0; $i<$binomial->dim;$i++){
               if($binomial->[$i]>0){
                  print "*x(",$i,")^",$binomial->[$i];
               }
            }
            print "-1";
            for(my $i=0; $i<$binomial->dim;$i++){
               if($binomial->[$i]<0){
                  print "*x(",$i,")^",-$binomial->[$i];
               }
            }
            print ",";
         }
         print "0;\n";
      }
      print "qring q = std(toric);\n";
      print "ideal I = ";
      if($Dgen->rows == 1){
         print "1;\n";
      } else {
         foreach my $g (@$Dgen){
            print "1";
            for(my $i=0; $i<$g->dim;$i++){
               if($g->[$i]>0){
                  print "*x(",$i,")^",$g->[$i];
               }
            }
            print ",";
         }
         print "0;\n";
      }
      print "I=std(I);\nI;\n";
      print "def L = minres(res(I,6));\n";
   }
   
   user_method ext(TDivisor, TDivisor){
      my $tv = $_[0];
      my $D1 = $_[1];
      my $D2 = $_[2];
      print $D1->COEFFICIENTS," - ",$D2->COEFFICIENTS,"\n";
      my $c = new Cone(INPUT_RAYS=>$tv->RAYS);
      my $tvc = new Polytope(POINTS=>unit_vector($tv->AMBIENT_DIM+1,0)/(zero_vector($c->FACETS->rows)|$c->FACETS));
      print $tvc->VERTICES;
      my $D1gs = $D1->SECTION_POLYTOPE;
      my $D2gs = $D2->SECTION_POLYTOPE;
      print "Vertices:\n", $D1gs->VERTICES;
      print "Inequalities:\n",$D1gs->INEQUALITIES;
      print "Product:\n",$D1gs->INEQUALITIES * transpose($D1gs->VERTICES);
      my $v1 = move_inside($tvc,$D1gs);
      my $v2 = move_inside($tvc,$D2gs);

      my $D1p = lower_lattice_points($D1gs);
      $D1p = new Matrix(map($_+$v1,@$D1p));
      $D1p = $D1p->minor(All,~[0]);
      print "New vertices:\n",$D1p,"\n";
      my $D2p = lower_lattice_points($D2gs);
      $D2p = new Matrix(map($_+$v2,@$D2p));
      $D2p = $D2p->minor(All,~[0]);
      print "New vertices:\n",$D2p,"\n";

      my $dual_cone = new Cone(INPUT_RAYS=>$c->FACETS);
      my $H = $dual_cone->HILBERT_BASIS;

      my $D1gen = new Matrix(map(find_positive_combination($_,$H,$c->RAYS),@$D1p));
      my $D2gen = new Matrix(map(find_positive_combination($_,$H,$c->RAYS),@$D2p));
      print "Check1:\n",transpose($H)*transpose($D1gen);
      print "Check2:\n",transpose($H)*transpose($D2gen);


      my $toric = $dual_cone->TORIC_IDEAL;
      # print "Toric ideal:\n",$toric;

      # Now all combinatorial information has been collected.
      # Generating input for Singular:
      print "LIB \"homolog.lib\";\n";
      print "ring R = 0,(x(0..",$H->rows-1,")),dp;\n";
      print "ideal toric = ";
      if($toric->rows == 0){
         print "0;\n";
      } else {
         foreach my $binomial (@$toric){
            print "1";
            for(my $i=0; $i<$binomial->dim;$i++){
               if($binomial->[$i]>0){
                  print "*x(",$i,")^",$binomial->[$i];
               }
            }
            print "-1";
            for(my $i=0; $i<$binomial->dim;$i++){
               if($binomial->[$i]<0){
                  print "*x(",$i,")^",-$binomial->[$i];
               }
            }
            print ",";
         }
         print "0;\n";
      }
      print "qring q = std(toric);\n";
      print "ideal I = ";
      if($D1gen->rows == 1){
         print "1;\n";
      } else {
         foreach my $g (@$D1gen){
            print "1";
            for(my $i=0; $i<$g->dim;$i++){
               if($g->[$i]>0){
                  print "*x(",$i,")^",$g->[$i];
               }
            }
            print ",";
         }
         print "0;\n";
      }
      print "ideal J = ";
      if($D2gen->rows == 1){
         print "1;\n";
      } else {
         foreach my $g (@$D2gen){
            print "1";
            for(my $i=0; $i<$g->dim;$i++){
               if($g->[$i]>0){
                  print "*x(",$i,")^",$g->[$i];
               }
            }
            print ",";
         }
         print "0;\n";
      }
      print "I=std(I);\nJ=std(J);\n";
      print "module M = syz(I);\nmodule N = syz(J);\n";
      for(my $i=0; $i<=10;$i++){
         print "Ext($i,M,N);\n";
      }
   }


}

# Find all lattice points of a polytope P that are not reachable
# from some other lattice point via the tail cone.
user_function lower_lattice_points(Polytope){
   my ($P) = @_;
   my $tail = $P->TAILCONE;
   my $vert = new Matrix(grep($_->[0]==1,@{$P->VERTICES}));
   my $rays = new Matrix(grep($_->[0]==0,@{$P->VERTICES}));
   print "Vertices:\n",$vert,"\n";
   print "Rays:\n",$rays,"\n";
   my @additional_vert = ();
   foreach my $v (@$vert){
      @additional_vert = ((map($_+$v,@$rays)),@additional_vert);
      print @additional_vert,"\n\n";
   }
   my $s = @additional_vert;
   print $s,"new Vertices.\n";
   my $Q = new Polytope(POINTS=>$vert/(new Matrix(@additional_vert)));
   my $candidates = $Q->LATTICE_POINTS;
   return $candidates;
   # my $facets = $P->FACETS;
   # my @result = grep(minimum($facets*$_)==0,@$candidates);
   # print "Computing lp succesful.\n",@result;
   # return new Matrix(@result);
}

# Return a combination of the Hilbert basis elements H that yield
# a given vector v. For containment checking we also need the facets
# F of the cone.
user_function find_positive_combination(Vector, Matrix,Matrix){
   my ($v, $H, $F) = @_;
   # Check if v is really contained:
   (minimum($F*$v)>=0) or die "v is not contained.";
   my $result = new Vector($H->rows);
   my $zero = new Vector($v->dim);
   while($v != $zero){
      for(my $i = 0; $i<$H->rows; $i++){
         my $veval = $F*$v;
         my $heval = $F*$H->[$i];
         my $max = maximum($veval);
         print $veval,"\n",$heval,"\n\n";
         my @quotient = map{
            $heval->[$_]>0 ? floor($veval->[$_]/$heval->[$_]) : $max;
         }@0..($veval->dim-1);
         my $quotient = new Vector(@quotient);
         my $factor = minimum($quotient);
         if($factor>0){
            $v = $v - $factor*$H->[$i];
            $result->[$i]+=$factor;
         }
      }
   }
   return $result;
}

# Return a vector that moves q into p.
# Note that we assume equality of the tail cones but do not check it.
sub move_inside{
   my ($p, $q) = @_;
   my $result = new Vector(zero_vector($q->AMBIENT_DIM+1));
   my $tail = $p->TAILCONE;
   my $qvert = $q->VERTICES;
   foreach my $facet (@{$p->FACETS}){
      my $val = 0;
      foreach my $q (@{$qvert}){
         my $test = $facet*$q;
         $val = $test<$val ? $test : $val;
      }
      if($val<0){
         foreach my $ray (@{$tail->RAYS}){
            if($facet*$ray>0){
               my $mult = ceil(-$val/($facet*$ray));
               $result += $mult*$ray;
               $qvert = new Matrix(map($_+$mult*$ray,@$qvert));
               last;
            }
         }
      }
   }
   return $result;
}
