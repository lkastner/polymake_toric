#  Copyright (c) 2012
#  by authors as mentioned on:
#  https://github.com/lkastner/polymake_toric/wiki/Authors
#  
#  Project home:
#  https://github.com/lkastner/polymake_toric
#
#  For licensing we cite the original Polymake code:
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

object HypersurfaceInTV {

	# Properties:

   # @category Basic properties
   # Evaluates true if the hypersurface is Calabi Yau.
	property CALABI_YAU : Bool;

   # @category Basic properties
   # The Laurent polynomial defining the hypersurface. For all
   # other computations we consider the closure in an ambient toric
   # variety.
	property EQUATION : Polynomial;
	
   # @category Basic properties
   # The Newton polytope of the defining Laurent polynomial.
	property NEWTON_POLYTOPE : Polytope;

   # @category Basic properties
   # The cones of the fan of the ambient toric variety that are necessary to 
   # describe the closure of the hypersurface.
	property RELEVANT_CONES : PolyhedralFan;

	#todo: From the Batyrev article.
	property REGULAR : Bool;

	property LOCAL_EQUATIONS : Map<Set<Int>, Polynomial>;

   # @category Basic properties
   # The tropical variety associated to the Laurent polynomial. We compute this
   # using gfan_tropicalhypersurface. Q: Is this correct?
	property TROPICAL_FAN : PolyhedralFan;
	
	# Rules:

	rule NEWTON_POLYTOPE : EQUATION {
		$this->NEWTON_POLYTOPE = newton($this->EQUATION);
	}

	rule TROPICAL_FAN : EQUATION {
		$this->TROPICAL_FAN = gfan_tropicalhypersurface($this->EQUATION);
	}
	
}

object ToricVariety {


	# Introducing property for having multiple hypersurfaces in a toric variety.
	property HYPERSURFACE : HypersurfaceInTV : multiple;

	# Rules:
	
	rule HYPERSURFACE.RELEVANT_CONES : HYPERSURFACE.TROPICAL_FAN, RAYS, MAXIMAL_CONES{
		# The idea of this method comes from the Sturmfels Maclagan book about tropical varieties.
		# For any subvariety of the torus one can compute which cones are really necessary for covering
		# the closure of this subvariety in the toric variety by intersecting the tropical variety
		# with the fan of the ambient toric variety.
		#
      # Currently this is very slow. Maybe it can be sped up be the following:
      # For each maximal cone in the tropical variety, compute every cone that is intersected non-trivially,
      # then compute the relevant parts.
      my $trop = $this->HYPERSURFACE->TROPICAL_FAN;
		my @interesting_cones = map($trop->cone($_),0..($trop->N_MAXIMAL_CONES-1));
		my @relevant = ();
		my $tvmc = $this->MAXIMAL_CONES;
		my $tvr = new Matrix<Rational>($this->RAYS);
		foreach my $C (@$tvmc) {
			#print $C;
			my $m = $tvr->minor($C,All);
			my $A = new Cone<Rational>(INPUT_RAYS=>$m);
			foreach my $t (@interesting_cones){
				# We will check, if A is intersected in its relative interior.
				my $tA = intersection($t, $A);
            # FIXME does this make sense ? (rel_int_point will be undef and cause problems otherwise ...)
				next if($tA->DIM == 0);
				# Choose an arbitrary point of the relative interior of the intersection.
				my $interior_point = $tA->REL_INT_POINT;
				my $fac = $A->FACETS;
				# We check on how many facets the relative interior point of the intersection lies.
				my @equations = grep($_*$interior_point == 0, @$fac);
				my $eq_mat = new Matrix<Rational>(@equations);
				my $test = $eq_mat->rows;
				if($test == 0){
					# If the point is on zero facets, it must be in the relative interior.
					push @relevant, $C;
				} else {
					# Else the point is in a subcone of A.
					# We choose the rays of A that satisfy the same equations.
					# Collecting them yields a face of A which is intersected in the relative interior.
					my $zero = zero_vector<Rational>($test);
					my @good_rays = grep(($eq_mat * $tvr->[$_] == $zero), @$C);
					push @relevant, new Set<Integer>(@good_rays);
				}
			}
			print "done\n";	
		}
		$this->HYPERSURFACE->RELEVANT_CONES = check_fan($tvr, new Array< Set<Integer>>(@relevant));
	}

	rule HYPERSURFACE.LOCAL_EQUATIONS : CONES, RAYS, HYPERSURFACE.NEWTON_POLYTOPE{
		$newton = $this->HYPERSURFACE->NEWTON_POLYTOPE;
		$cones = $this->CONES;
		$rays = $this->RAYS;
		foreach my $d (@$cones){
			foreach my $c (@$d){
				
			}
		}
	}
}

user_function cocoref_new(Matrix) {
	stop_here();
	my($rays) = @_;
	my $dim = $rays->cols();
	my $m = $rays->rows();
	my @init_cones = all_subsets_of_k($dim, 0..($m)-1);
	@init_cones = map(new Set($_), @init_cones);
	# print @init_cones;
	@init_cones = map((new Matrix<Rational>(@$rays[@$_])), @init_cones);
	@init_cones = grep(rank($_) == $dim, @init_cones);
	@init_cones = grep {
		my $facets = transpose(inv($_));
		my $contained = grep{minimum($facets * $_)>=0} @$rays;
		$contained == $dim
	} @init_cones;
	@init_cones = map((new Cone<Rational>(INPUT_RAYS=>$_)), @init_cones);
	@init_cones = unique(@init_cones);
	my @refined = ();
	my $added = 1;
	my @nc = @init_cones;
	my $n = @init_cones;
	print "$n initial cones.\n";
	
	my $i = 0;
	@init_cones = map{
		my @elem = ();
		push @elem, new Set<Int>($i);
		push @elem, $_;
		$i++;
		[@elem]
	} @init_cones;
	
	my @combinations = map($_->[0], @init_cones);
	my @new_cones = @init_cones;
	while($added == 1){
		$added = 0;
		my @collected_cones = ();
		foreach my $c (@new_cones){
			my $index = $c->[0];
			my @intersections = grep((($index + $_ )-($index * $_))->size == 2, @combinations);
			@intersections = map($_ - $index, @intersections);
			my @ui = ();
			foreach my $i (@intersections) {
				my $identicals = grep($_ == $i, @ui);
				if($identicals == 0){
					push @ui, $i;
				}
			}
			@intersections = @ui;
			my @done = ();
			my @todo = ();
			foreach my $i (@intersections) {
				my $indexset = $index + $i;
				my $b = grep( $_->[0] == $indexset, @collected_cones );
				if($b > 0){
					push @done, $i;
				} else {
					push @todo, $i;
				}
			}
			#print @todo,"\n";
			@todo = map {
				my $i = $_;
				my @ic = grep( $_->[0] == $i, @init_cones);
				my $primitive_cone = @ic->[0]->[1];
				my @intersect = ();
				push @intersect, ($index + $i);
				push @intersect, intersection($primitive_cone, $c->[1]);
				[@intersect]
			} @todo;
			@todo = grep($_->[1]->DIM == $dim, @todo);
			@todo = grep(!included_polyhedra($c->[1], $_->[1]), @todo);
			my $keep1 = @done;
			my $keep2 = @todo;
			my $keep = $keep1 + $keep2;
			if ($keep == 0){
				my $identicals = grep(equal_polyhedra($_->[1], $c->[1]), @refined);
				# print "There are $identicals copies of this cone.\n";
				if ($identicals == 0){
					push @refined, $c;
				}
				my $ref = @refined;
				# print "Pushed something: $ref\n";
				next;
			}  
			$added = 1;
			@collected_cones = (@collected_cones, @todo);
			# print "done.\n";
		}
		my @uniques = ();
		foreach my $col (@collected_cones){
			my $identicals = grep(equal_polyhedra($col->[1], $_->[1]), (@uniques, @refined));
			if($identicals == 0){
				push @uniques, $col;
			}
		}	
		@new_cones = @uniques;
		my $collected = @new_cones;
		@combinations = map($_->[0], @new_cones);
		print "Collected $collected new cones.\n";
	}
	my @good_comb = map($_->[0], @refined);
	@refined = map($_->[1], @refined);
	@refined = unique(@refined);
	my $in = @refined;
	
	print "Number of resulting cones: $in.\n";
	return check_fan_objects(@refined);
}

user_function cocoref_bruteforce(Matrix) {
	my($rays) = @_;
	my $dim = $rays->cols();
	my $m = $rays->rows();
	my @init_cones = all_subsets_of_k($dim, 0..($m)-1);
	@init_cones = map(new Set($_), @init_cones);
	# print @init_cones;
	@init_cones = map((new Matrix<Rational>(@$rays[@$_])), @init_cones);
	@init_cones = grep(rank($_) == $dim, @init_cones);
	@init_cones = map((new Cone<Rational>(INPUT_RAYS=>$_)), @init_cones);
	@init_cones = unique(@init_cones);
	@init_cones = grep{
		my $facets = $_->FACETS;
		my $contained = grep{minimum($facets * $_)>=0} @$rays;
		$contained == $dim
	} @init_cones;
	my @refined = ();
	my $added = 1;
	my @nc = @init_cones;
	my $n = @init_cones;
	print "$n initial cones.\n";
	while($added == 1){
		$added = 0;
		my @collection = ();
		foreach my $c (@nc){
			my @intersections = map(intersection($c, $_), @init_cones);
			@intersections = grep($_->DIM == $dim, @intersections);
			@intersections = grep(!included_polyhedra($c, $_), @intersections);
			my $keep = @intersections;
			if ($keep == 0){
				push @refined, $c;
				@refined = unique(@refined);
				my $ref = @refined;
				# print "Pushed something: $ref\n";
				next;
			}  
			$added = 1;
			@intersections = unique(@intersections);
			@collection = (@collection, @intersections);
			print "done.\n";
		}
		@collection = unique(@collection);
		foreach my $r (@refined){
			@collection = grep(!equal_polyhedra($r, $_), @collection);
		}
		my $collected = @collection;
		print "Collected $collected new cones.\n";
		@nc = @collection;
	}
	
	@refined = unique(@refined);
	my $in = @refined;
	
	print "Number of resulting cones: $in.\n";
	return check_fan_objects(@refined);
}

sub unique {
	my (@cones) = @_;
	my @result = ();
	my $n = @cones;
	while($n>0){
		my $c = pop @cones;
		@cones = grep(!equal_polyhedra($c, $_), @cones);
		push @result, $c;
		$n = @cones;
	}
	return @result;
}


user_function chow_quotient(Polynomial){
	my ($g) = @_;
	print "Defining Polynomial:\n$g\n\n";
	my $degs = dense($g->monomials_as_matrix);
	print "Exponents:\n$degs\n";
	my $coeffs = $g->coefficients_as_vector;
	print "Coefficients:\n$coeffs\n\n";
	my @r = @$degs;
	my $c = $r[0];
	#print $c;
	my @diffmatrows  = map($_-$c, @r);
	my $diffmat = new Matrix<Integer>(@diffmatrows);
	print "Pairwise differences:\n$diffmat\n";
	my $D = null_space($diffmat);
	print "D:\n$D\n";
	my $B = transpose(null_space($D));
	print "B:\n$B\n";
	# Test for exactness:
	# print $D*$B;
	my $deg_g = $D*$c;
	# Test for homogenoucity:
	# print "degree of g:\n$deg_g\n\n";
	# print $D*transpose(-$degs);
	my $dm1 = new Polytope<Rational>(EQUATIONS=>($deg_g | $D));
	my $a = $dm1->DIM;
	# Checking whether dimension is correct:
	# print "Dim:\n$a\n";
	my $zero = zero_vector($B->cols);
	my @fm = map(((ones_vector(1) | (-1)*(new Vector<Rational>($_)))/($zero | transpose(new Matrix<Rational>($B)))), @$degs);
	@fm = map((new Polytope<Rational>(POINTS=>$_)), @fm);
	my $good_points = $dm1;
	foreach my $P (@fm){
		$good_points = intersection($good_points, $P);
	}
	my $good_vert = $good_points->VERTICES->[0];
	# print $good_vert;
	my $par_vert = (cube($B->cols,0)->VERTICES)*($good_vert / ($zero |transpose(new Matrix<Rational>($B))));
	# print $par_vert;
	my $lat = (new Polytope<Rational>(POINTS=>$par_vert))->VERTICES;
	# print "\nOk lattice points:\n";
	my $p = -$lat->[0]->slice(1);
	# print "P: $p\n";
	my $test = new Matrix<Rational>(map($_-$p,@$degs));
	# print $test;
	# print $D*transpose($test);
	my @preim = map((new Polytope<Rational>(EQUATIONS=>(($p-$_) | new Matrix<Rational>($B))))->VERTICES, @$degs);
	# print @preim;
	my $new_degs = new Matrix<Int>(map($_->[0]->slice(1), @preim));
	# Building ring for output equation:
	my $nvars = $new_degs->cols;
	my @vars = ( map { "x$_" } (1..$nvars) );
	my $R = new Ring(@vars);
	my $g_tilda = new Polynomial($new_degs,$coeffs,$R); 
	print "g_tilda: $g_tilda\n";
	my $ambient_tv = cast<ToricVariety>(cocoref_new(new Matrix<Rational>($B)));
	my $hs = $ambient_tv->add("HYPERSURFACE", EQUATION=>$g_tilda);
	print "Equation: ",$hs->EQUATION,"\n";
	return $ambient_tv;
}
