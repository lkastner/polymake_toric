

#######################################
#######################################
###
### Toric Variety
###
#######################################
#######################################

declare object ToricVariety<Scalar=Rational [ typechecks::is_ordered_field(Scalar) ]> : PolyhedralFan<Scalar>; 

object PolyhedralFan<Rational> {

	auto_cast : ToricVariety<Rational>;

}

#######################################
#######################################
###
### Hypersurface in Toric Variety
###
#######################################
#######################################

declare object HypersurfaceInTV;

INCLUDE
	toric_variety_properties.rules
	gfan_hyp_brut.rules
	hypersurfaceInTV_properties.rules
	toric_divisor.rules

user_function add_ray(PolyhedralFan, Vector){
	my($fan, $ray) = @_;
	my $oldrays = $fan->RAYS;
	my $newrays = $oldrays / $ray;
	print $newrays;
	my $mc = $fan->MAXIMAL_CONES;
	for my $f (@$mc) {
		print "$f\n";
		my $gens = new Matrix<Rational>(@$oldrays[@$f]);
		print $gens;
	}
}


# Checking if a fan is complete by checking if every facet appears with an even factor.
user_function is_complete(PolyhedralFan<Rational>){
	my ($f) = @_;
	my $check = (1 == 1);
	my $mc = $f->MAXIMAL_CONES;
	my $fanrays = new Matrix<Rational>($f->RAYS);
	my @init_cones = map((new Matrix<Rational>(@$fanrays[@$_])), @$mc);
	@init_cones = map((new Cone<Rational>(INPUT_RAYS=>$_)), @init_cones);
	my @collection = ();
	foreach my $c (@init_cones){
		my $rays = $c->RAYS;
                my $frc = $c->RAYS_IN_FACETS;
		#print $frc;
		#print $rays;
		my @facet_cones = map((new Matrix<Rational>(@$rays[@$_])), @$frc);
		@facet_cones = map((new Cone<Rational>(INPUT_RAYS=>$_)), @facet_cones);
		@collection = (@collection, @facet_cones);
	}
	foreach my $facet (@collection){
		my $ref = grep(equal_polyhedra($facet, $_), @collection);
		print "$ref\n";
		$check = $check && ($ref == 2);
	}
	print "$check\n";
	return $check;
}

# Checking if two fans are the same
user_function equal_fans(PolyhedralFan<Rational>, PolyhedralFan<Rational>){
	my ($f, $g) = @_;
	if ($f->RAYS->rows != $g->RAYS->rows)
		{return (0 == 1);}
	if ($f->N_MAXIMAL_CONES != $g->N_MAXIMAL_CONES)
		{return (0 == 1);}

	my $map = new Map<Vector<Rational>,Int>;
	my $i = 0;
	foreach my $r (@{$f->RAYS}){
		$map->{$r} = $i;
		$i++;
	}
	foreach my $r (@{$g->RAYS}){
		if (!exists($map->{$r}))
		{print "la\n";
		return (0 == 1);}
	}
	my $mf = $f->MAXIMAL_CONES;
	my @mcf = @$mf;
	my $mg = $g->MAXIMAL_CONES;
	my @mcg =@$mg;
	foreach my $c (@mcg){
		my $equals = grep( (new Set<Int>(map{$map->{$g->RAYS->[$_]}} @$c)) == $_, @mcf); 
		if ($equals == 0) 
			{return (0==1);}
	}	
	
	return (0==0);
}















