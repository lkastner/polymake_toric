#  Copyright (c) 2012
#  by authors as mentioned on:
#  https://github.com/lkastner/polymake_toric/wiki/Authors
#  
#  Project home:
#  https://github.com/lkastner/polymake_toric
#
#  For licensing we cite the original Polymake code:
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

object ToricVariety {
   
   property SUBVARIETY : SubvarietyInTV : multiple;
   
   object SubvarietyInTV {

      rule NEWTON_POLYTOPE : EQUATIONS {
         my $eq = $this->EQUATIONS->GENERATORS->[0];
         $this->NEWTON_POLYTOPE = newton($eq);
      }
      precondition : HYPERSURFACE;

      rule TROPICAL_FAN : EQUATIONS {
         my $eq = $this->EQUATIONS->GENERATORS->[0];
         $this->TROPICAL_FAN = gfan_tropicalhypersurface($eq);
      }
      precondition : HYPERSURFACE;

   }

	rule SUBVARIETY.RELEVANT_CONES : SUBVARIETY.TROPICAL_FAN, RAYS, MAXIMAL_CONES{
		# The idea of this method comes from the Sturmfels Maclagan book about tropical varieties.
		# For any subvariety of the torus one can compute which cones are really necessary for covering
		# the closure of this subvariety in the toric variety by intersecting the tropical variety
		# with the fan of the ambient toric variety.
		#
      # Currently this is very slow. Maybe it can be sped up be the following:
      # For each maximal cone in the tropical variety, compute every cone that is intersected non-trivially,
      # then compute the relevant parts.
      my $trop = $this->SUBVARIETY->TROPICAL_FAN;
		my @interesting_cones = map($trop->cone($_),0..($trop->N_MAXIMAL_CONES-1));
		my @relevant = ();
		my $tvmc = $this->MAXIMAL_CONES;
		my $tvr = new Matrix<Rational>($this->RAYS);
		foreach my $C (@$tvmc) {
			#print $C;
			my $m = $tvr->minor($C,All);
			my $A = new Cone<Rational>(INPUT_RAYS=>$m);
			foreach my $t (@interesting_cones){
				# We will check, if A is intersected in its relative interior.
				my $tA = intersection($t, $A);
            # FIXME does this make sense ? (rel_int_point will be undef and cause problems otherwise ...)
				next if($tA->DIM == 0);
				# Choose an arbitrary point of the relative interior of the intersection.
				my $interior_point = $tA->REL_INT_POINT;
				my $fac = $A->FACETS;
				# We check on how many facets the relative interior point of the intersection lies.
				my @equations = grep($_*$interior_point == 0, @$fac);
				my $eq_mat = new Matrix<Rational>(@equations);
				my $test = $eq_mat->rows;
				if($test == 0){
					# If the point is on zero facets, it must be in the relative interior.
					push @relevant, $C;
				} else {
					# Else the point is in a subcone of A.
					# We choose the rays of A that satisfy the same equations.
					# Collecting them yields a face of A which is intersected in the relative interior.
					my $zero = zero_vector<Rational>($test);
					my @good_rays = grep(($eq_mat * $tvr->[$_] == $zero), @$C);
					push @relevant, new Set<Integer>(@good_rays);
				}
			}
			print "done\n";	
		}
		$this->SUBVARIETY->RELEVANT_CONES = check_fan($tvr, new Array< Set<Integer>>(@relevant));
	}

	rule SUBVARIETY.LOCAL_EQUATIONS : CONES, RAYS, SUBVARIETY.NEWTON_POLYTOPE{
		$newton = $this->SUBVARIETY->NEWTON_POLYTOPE;
		$cones = $this->CONES;
		$rays = $this->RAYS;
		foreach my $d (@$cones){
			foreach my $c (@$d){
				
			}
		}
	}
}
