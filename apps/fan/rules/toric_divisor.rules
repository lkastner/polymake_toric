#  Copyright (c) 2012
#  by authors as mentioned on:
#  https://github.com/lkastner/polymake_toric/wiki/Authors
#  
#  Project home:
#  https://github.com/lkastner/polymake_toric
#
#  For licensing we cite the original Polymake code:
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

object ToricVariety {

   object TDivisor {
         
      rule INTEGRAL : COEFFICIENTS {		
         $this->INTEGRAL = (eliminate_denominators($this->COEFFICIENTS) - $this->COEFFICIENTS == zero_vector($this->COEFFICIENTS->dim));
      }
      
      rule CARTIER :  {
         $this->CARTIER = 1;
      }
      precondition : PRINCIPAL;


   }
     rule DIVISOR.PRINCIPAL : RAYS, DIVISOR.COEFFICIENTS {
		my $c = $this->DIVISOR->COEFFICIENTS;
		my $eq = -$c | $this->RAYS;
		my $bla = new Polytope<Rational>(EQUATIONS => $eq);
		$bla->VERTICES;
		my $sol = grep($_->[0]==1, @{$bla->LATTICE_POINTS});
		$this->DIVISOR->PRINCIPAL=($sol > 0);
	}

	rule DIVISOR.SECTION_POLYTOPE : RAYS, DIVISOR.COEFFICIENTS {
		my $a = $this->DIVISOR->COEFFICIENTS;
		my $v = $this->RAYS;		
		my $ineq = $a | $v;
		#print $ineq;
		$this->DIVISOR->SECTION_POLYTOPE = new Polytope<Rational>(INEQUALITIES => $ineq);
	}

	rule DIVISOR.CARTIER, DIVISOR.CARTIER_DATA : RAYS, DIVISOR.COEFFICIENTS, MAXIMAL_CONES {
		my $maxcones = $this->MAXIMAL_CONES;
		my $map = new Map<Set<Int>,Vector>;
		my $rays = $this->RAYS;
		my $a = $this->DIVISOR->COEFFICIENTS;
		foreach my $s (@$maxcones){
			my $eq = $a->slice($s) | $rays->minor($s,All);
			my $bla = new Polytope<Rational>(EQUATIONS => $eq);
			$bla->VERTICES;
			if ($bla->N_LATTICE_POINTS == 0){
				$this->DIVISOR->CARTIER = 0;
				return;			
			}
			$map->{$s} = $bla->LATTICE_POINTS->row(0);
		}
		$this->DIVISOR->CARTIER = 1;
		$this->DIVISOR->CARTIER_DATA = $map;
	}

	rule DIVISOR.BASEPOINT_FREE : DIVISOR.CARTIER_DATA, MAXIMAL_CONES, DIVISOR.SECTION_POLYTOPE {
		my $maxcones = $this->MAXIMAL_CONES;
		my $P = $this->DIVISOR->SECTION_POLYTOPE;
		my $map = $this->DIVISOR->CARTIER_DATA;
		foreach my $s (@$maxcones){
			if (!$P->contains($map->{$s})){
				$this->DIVISOR->BASEPOINT_FREE = 0;
				return;
			}
			
		}
		$this->DIVISOR->BASEPOINT_FREE = 1;
	
	}
	precondition : DIVISOR.CARTIER;
	precondition : PURE;
	precondition : FULL_DIM;

  # computes whether a toric divisor is [[NEF]]
  # algorithm: check whether the divisor is in the nef cone of the variety
  rule DIVISOR.NEF : DIVISOR.COEFFICIENTS, NEF_CONE.FACETS, NEF_CONE.LINEAR_SPAN, RATIONAL_DIVISOR_CLASS_GROUP.PROJECTION {
    my $f = $this->NEF_CONE->FACETS;
    my $l = $this->NEF_CONE->LINEAR_SPAN;
    my $pd = $this->DIVISOR->COEFFICIENTS * $this->RATIONAL_DIVISOR_CLASS_GROUP->PROJECTION;
    my $v = $f*$pd;
    
    foreach (@{$v}) { if ( $_ < 0 ) { $this->DIVISOR->NEF = 0; return; } }
    if ( $l->rows ) { 
      my $w = $l*$pd;
      foreach (@{$w}) { if ( $_ != 0 ) { $this->DIVISOR->NEF = 0; return; } }
    }
    $this->DIVISOR->NEF = 1;
  }
  weight 1.10;
	
}



	
	

