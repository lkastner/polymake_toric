object Cone<Rational>{
   
   property INTERESTING_DEGREES : Matrix;

}

declare object Deformation;

object Deformation{
   
   property SIGMA : Cone;

   property DEGREE : Vector;

   property Q0 : Polytope;

   property Q1 : Polytope;

   property QR : Polytope;

   property TAUTOLOGICAL_CONE : Cone;


#rule TAUTOLOGICAL_CONE : DECOMPOSITION, SIGMA{
      #todo
#   }

#   rule SIGMA : DECOMPOSITION{
      #trivial todo
#   }

   rule SIGMA : QR{
      #...
   }

   rule QR : Q0, Q1 {
      $this->QR = minkowski_sum($this->Q0, $this->Q1);
   }

   rule TAUTOLOGICAL_CONE : Q0, Q1 {
      my $p = $this->Q0;
      my $q = $this->Q1;
      my $vp = $p->VERTICES->minor(All, ~[0]);
      my $vq = $q->VERTICES->minor(All, ~[0]);
      $vp = (new Matrix($vp) | ones_vector()| zero_vector);
      $vq = (new Matrix($vq) | zero_vector()| ones_vector);
      $this->TAUTOLOGICAL_CONE = new Cone(INPUT_RAYS=>($vp / $vq));
   }

   rule QR : SIGMA, DEGREE{
      my $rays = $this->SIGMA->RAYS;
      my $R = $this->DEGREE;
      # This evaluates $R on each $ray:
      my @v = map($_*$R, @$rays);
      # We write the height in front of each vertex:
      my $vert = (new Vector(@v)|$rays);
      # print $vert;
      # The new Polytope:
      $this->QR = new Polytope<Rational>(POINTS=>$vert);
   }

}

object Polytope<Rational>{
   
   property DEFORMATION_MINKOWSKI_CONE : Cone;

}

user_function find_possible_decompositions(Polytope<Rational>){
   my($P) = @_;
   # TODO: Mess with non-lattice polytopes.
   my $mink_cone = $P->MINKOWSKI_SUMMAND_CONE;
   my $pos_orth = cube($mink_cone->AMBIENT_DIM);
   my $vert = zero_vector() | new Matrix($mink_cone->RAYS);
   $vert = (ones_vector(1)|zero_vector($mink_cone->AMBIENT_DIM))/$vert;
   my $ineq = new Matrix(ones_vector($vert->cols));
   $ineq->col(0) *= -1;
   print $ineq;
   my $q = new Polytope(POINTS=>$vert);
   # We only want points with positive entries.
   $q = intersection($q, $pos_orth);
   # This will select those points, that aren't zero.
   $q = intersection($q, new Polytope(INEQUALITIES=>$ineq));
   my $good_summands = $q->LATTICE_POINTS->minor(All, ~[0]);
   print $good_summands;
   my $eq = -ones_vector($good_summands->cols) | (new Matrix(transpose($good_summands)));
   $ineq = zero_vector($good_summands->rows) | dense(unit_matrix($good_summands->rows));
   print $eq;
   print $ineq;
   $q = new Polytope(EQUATIONS=>$eq, INEQUALITIES=>$ineq);
   my $sol = $q->LATTICE_POINTS->minor(All, ~[0]);
   print $sol;
   # Just checking whether the combinations sum up to our polytope.
   print transpose($good_summands)*transpose($sol);
}
