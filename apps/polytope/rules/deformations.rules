object Cone<Rational>{
   
   property INTERESTING_DEGREES : Matrix;

}

declare object Deformation;

object Deformation{
   
   property SIGMA : Cone;

   property DEGREE : Vector;

   property Q0 : Polytope;

   property Q1 : Polytope;

   property QR : Polytope;

   property TAUTOLOGICAL_CONE : Cone;


#rule TAUTOLOGICAL_CONE : DECOMPOSITION, SIGMA{
      #todo
#   }

#   rule SIGMA : DECOMPOSITION{
      #trivial todo
#   }

   rule SIGMA : QR{
      #...
   }

   rule QR : Q0, Q1 {
      $this->QR = minkowski_sum($this->Q0, $this->Q1);
   }

   rule TAUTOLOGICAL_CONE : Q0, Q1 {
      my $p = $this->Q0;
      my $q = $this->Q1;
      my $vp = $p->VERTICES->minor(All,~(0));
      my $vq = $q->VERTICES->minor(All,~(0));
      $vp = (new Matrix($vp) | ones_vector()| zero_vector);
      $vq = (new Matrix($vq) | zero_vector()| ones_vector);
      $this->TAUTOLOGICAL_CONE = new Cone(INPUT_RAYS=>($vp / $vq));
   }

   rule QR : SIGMA, DEGREE{
      my $rays = $this->SIGMA->RAYS;
      my $R = $this->DEGREE;
      # This evaluates $R on each $ray:
      my @v = map($_*$R, @$rays);
      # We write the height in front of each vertex:
      my $vert = (new Vector(@v)|$rays);
      # print $vert;
      # The new Polytope:
      $this->QR = new Polytope<Rational>(POINTS=>$vert);
   }

}

object Polytope<Rational>{
   
   property DEFORMATION_MINKOWSKI_CONE : Cone;

}
