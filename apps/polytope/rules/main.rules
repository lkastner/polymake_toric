object Polytope<Rational> {

	property NICE_MINKOWSKI_SUMMAND : Polytope;

	property TAILCONE : Polytope;

	rule NICE_MINKOWSKI_SUMMAND : MINKOWSKI_SUMMAND_CONE, GRAPH {
		my $minkp = new Matrix<Rational>($this->MINKOWSKI_SUMMAND_CONE->EQUATIONS);
		my $eqs = new Matrix<Rational>($this->GRAPH->EDGE_DIRECTIONS);
		my $count = 0;
		my @factors = ();
		foreach my $e (@$eqs){
			my $factor = new Rational(1);
   			my $test = primitive(eliminate_denominators($e));
				for(my $i = 0; $i < $e->dim; $i++){
					if($e->[$i] != 0){
						$factor = (new Rational($test->[$i]))/(new Rational($e->[$i]));
						last;
					}
				}
			#print $e, " ", $test, " factor: ", $factor, "\n";
			$minkp->col($count) *= $factor;
			push @factors, $factor;
			$count++;
		}
		$eqs = primitive(eliminate_denominators($eqs));
		my $eq = new Matrix<Rational>(zero_vector($minkp->rows) | $minkp);
		my $ineq = new Matrix<Rational>(-ones_vector($minkp->cols) | dense(unit_matrix($minkp->cols)));
		#print $eq,"\n";
		#print $ineq,"\n";
		my $newMink = new Polytope<Rational>(EQUATIONS=>$eq, INEQUALITIES=>$ineq);
		my $newMinkVertices = $newMink->VERTICES;
		my $q;
		foreach my $v (@$newMinkVertices){
			if ($v->[0]==1){
				$q = new Vector<Rational>($v->slice(1));
				last;
			}
		}
		#print $q,"\n";
		my $i = 0;
		foreach my $f (@factors){
			$q->[$i] *= $f;
			$i++;
		}
		$this->NICE_MINKOWSKI_SUMMAND = $this->MINKOWSKI_SUMMAND_POINT(primitive(eliminate_denominators($q)));
	
	}

	rule TAILCONE : FACETS, AFFINE_HULL {
		my $ineq = $this->FACETS;
		my $eq = $this->AFFINE_HULL;
		print $ineq;
		my $newineq = (new Vector<Rational>($ineq->rows)) | $ineq->minor(All,~[0]);
		$this->TAILCONE = new Polytope<Rational>(INEQUALITIES=>$newineq);	
	}

}

sub pairwise_differences {
	my ($in) = @_;
	my @out = ();
	my $c = $in->[0];
	foreach my $p (@$in) {
		if($p != $c) {
			push @out, ($p-$c);
		}
	}
	return new Matrix<Integer>(\@out);
}
