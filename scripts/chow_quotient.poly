#$r=new Ring(qw(x y));
#($x,$y)=$r->variables;
#$p=1+$x+$y;
#$t = $p->get_ring;
#print $t->variables;
#print $p->coefficients_as_vector;


application "fan";

# Some small examples and code to test basic methods.
#$r=new Ring(qw(x y));
#($x,$y)=$r->variables;
#$p=1+$x+$y;
#$htv = new HypersurfaceInTV(EQUATION=>$p, AMBIENT_TV=>cast<ToricVariety>(normal_fan(cube(2))));
#print $htv->RELEVANT_CONES->MAXIMAL_CONES;

#$f = normal_fan(cube(3));
#$t = cast<ToricVariety>($f);

#$m = new Matrix<Int>[[1,0],[0,1]];
#$c = new Vector<Rational>([1,2]);
#$a = new HypersurfaceInTV(EXPONENTS=>$m, COEFFICIENTS=>$c);

#$m1 = new Matrix<Int>[[1,0],[0,1],[0,0]];
#$c1 = new Vector<Rational>([1,1,1]);
#$a1 = new HypersurfaceInTV(EXPONENTS=>$m1, COEFFICIENTS=>$c1);

#$f = normal_fan(cube(2));
#$v = new Vector<Rational>([1,1]);
#add_ray($f, $v);

#$r1 = new Matrix<Rational>([2,1,1],[-1,0,-1],[-1,-1,0],[0,0,1],[0,1,0],[1,0,0]);
#print $r1;
#$col1 = cocoref_bruteforce($r1);

# Testing with Renes input:
#$ring = new Ring(qw(x y z w));
#($x,$y,$z,$w) = $ring->variables;
#$g = $x*$x+$y*$y+$z*$z+$w*$w-2*($x+$y+$x*$z+$x*$w+$y*$z+$y*$w+$z*$w)+4*($y*$z*$w+$x);
#print $g;
#$tv = cast<ToricVariety>(normal_fan(cube(4)));
#$htv = new HypersurfaceInTV(EQUATION=>$g, AMBIENT_TV=>$tv);
#$r = new Matrix<Rational>([2,1,1,1],[-1,0,-1,-1],[-1,-1,0,-1],[-1,-1,-1,0],[0,0,0,1],[0,0,1,0],[0,1,0,0],[1,0,0,0]);
#print $r;
#$col = cocoref_new($r);
#$col1 = cocoref_bruteforce($r);
#$htv = new HypersurfaceInTV(EQUATION=>$g, AMBIENT_TV=>cast<ToricVariety>($col1));
#print $htv->RELEVANT_CONES->MAXIMAL_CONES;

# Testing Chow Quotient:
#$ring = new Ring(qw(a b c d e f g h));
#($x000, $x001, $x010, $x011, $x100, $x101, $x110, $x111) = $ring->variables;
#$g = $x000*$x000*$x111*$x111 + $x001*$x001*$x110*$x110 + $x010*$x010*$x101*$x101 + $x011*$x011*$x100*$x100;
#$g = $g - 2*($x000*$x001*$x110*$x111 + $x000*$x010*$x101*$x111 + $x000*$x100*$x011*$x111 + $x001*$x010*$x101*$x110 + $x001*$x100*$x011*$x110 + $x010*$x100*$x011*$x101);
#$g = $g + 4*($x000*$x011*$x101*$x110 + $x001*$x010*$x100*$x111);
#$cq = chow_quotient($g);

# Specific computation for the hyperdeterminant.
#$htv = load("hyperdet.htv");
#$amb = $htv->AMBIENT_TV;
#$rel = $htv->RELEVANT_CONES;
#$map = new Map<Vector<Rational>, Int>;
#$i = 0;
#foreach my $r (@{$amb->RAYS}){
#	print $r;
#	$map->{$r} = $i;
#	$i++;
#}
#@relc = ();
#foreach my $c (@{$rel->MAXIMAL_CONES}){
#	push @relc, new Set<Int>(map{$map->{$rel->RAYS->[$_]}} @$c);
#}
#print @relc;
#$s = $relc[0];
#map($s+=$_, @relc);
#$ambmc = $amb->MAXIMAL_CONES;
#@ambmc = @$ambmc;
#$cs = (new Set<Int>([0..($amb->RAYS->rows-1)]))-$s;
#print $cs;
#@non_bad = grep(($cs * $_)->size == 0, @ambmc);
#print @non_bad;
#foreach my $t (@$cs){
#	my @cont = grep(incl((new Set<Int>($t)), $_) == -1, @ambmc);
#	my $nc = new Set<Int>($cont[0]);
#	map($nc += (new Set<Int>($_)), @cont);
#	$nc -= $cs;
#	$nc -= new Set<Int>($t);
#	print $nc;
#	push @non_bad, $nc;
#	print @cont, "\n\n";
#}

$p = load("cool.poly");
$minkp = new Matrix<Rational>($p->MINKOWSKI_SUMMAND_CONE->EQUATIONS);
$eqs = new Matrix<Rational>($p->GRAPH->EDGE_DIRECTIONS);
$count = 0;
@factors = ();
foreach my $e (@$eqs){
	my $factor = new Rational(1);
   my $test = primitive(eliminate_denominators($e));
	for(my $i = 0; $i < $e->dim; $i++){
		if($e->[$i] != 0){
			$factor = (new Rational($test->[$i]))/(new Rational($e->[$i]));
			last;
		}
	}
	print $e, " ", $test, " factor: ", $factor, "\n";
	$minkp->col($count) *= $factor;
	push @factors, $factor;
	$count++;
}
$eqs = primitive(eliminate_denominators($eqs));
$eq = new Matrix<Rational>(zero_vector($minkp->rows) | $minkp);
$ineq = new Matrix<Rational>(-ones_vector($minkp->cols) | dense(unit_matrix($minkp->cols)));
$newMink = new Polytope<Rational>(EQUATIONS=>$eq, INEQUALITIES=>$ineq);
$q = new Vector<Rational>($newMink->VERTICES->[0]->slice(1));
$i = 0;
foreach my $f (@factors){
	$q->[$i] *= $f;
	$i++;
}
$ms = $p->MINKOWSKI_SUMMAND_POINT($q);
