

CREDIT gfan
  Gfan is a software package for computing Groebner fans and tropical varieties.
  Copyright by Anders Jensen
  http://www.math.tu-berlin.de/~jensen/software/gfan/gfan.html

# path to gfan
custom $gfan_tropicalhypersurface;

custom $gfan_tropicalbruteforce;

CONFIGURE {
    find_program($gfan_tropicalhypersurface, "gfan_tropicalhypersurface");
    find_program($gfan_tropicalbruteforce, "gfan_tropicalbruteforce");
}


#######################################
#######################################
###
### Toric Variety
###
#######################################
#######################################

declare object ToricVariety<Scalar=Rational [ typechecks::is_ordered_field(Scalar) ]> : PolyhedralFan<Scalar>; 

object PolyhedralFan<Rational> {

	auto_cast : ToricVariety<Rational>;

}

object ToricVariety {

	# Properties:

	property AFFINE : Bool;

	property PROJECTIVE : Bool;

	property SMOOTH = override SMOOTH_FAN;
	
	# Rules:

	rule PROJECTIVE : MAXIMAL_CONES {
		$this->PROJECTIVE = 1;
	}
	
}

#######################################
#######################################
###
### Hypersurface in Toric Variety
###
#######################################
#######################################

declare object HypersurfaceInTV;

object HypersurfaceInTV {

	# Properties:
	
	property AMBIENT_TV : ToricVariety;
	
	property EQUATION : Polynomial;
	
	property RELEVANT_CONES : PolyhedralFan;

	property TROPICAL_FAN : PolyhedralFan;
	
	
	# Rules:
	
	rule RELEVANT_CONES : TROPICAL_FAN, AMBIENT_TV{
		my $TV = $this->AMBIENT_TV;
		my $trop = $this->TROPICAL_FAN;
		my @interesting_cones = map($trop->cone($_),0..($trop->N_MAXIMAL_CONES-1));
		# print "bla\n";	

		my @relevant = ();
		my $tvmc = $TV->MAXIMAL_CONES;
		my $tvr = new Matrix<Rational>($TV->RAYS);
		#print $tvr;
		foreach my $C (@$tvmc) {
			#print $C;
			my $m = new Matrix<Rational>(@$tvr[@$C]);
			#print $m;
			my $A = new Cone<Rational>(INPUT_RAYS=>$m);
			foreach my $t (@interesting_cones){
				my $tA = intersection($t, $A);
				if($tA->CONE_DIM < $t->CONE_DIM){
					#print "dim too low\n";
					next;
				} else {
					#print "maybe ok\n";
					my $tar = $tA->RAYS;
					my $one = ones_vector($tar->rows);
					my $interior_point = transpose($tar) * $one;
					my $fac = $A->FACETS;
					# print "\n\nFacets:\n$fac\n";
					my @equations = grep($_*$interior_point == 0, @$fac);
					my $eq_mat = new Matrix<Rational>(@equations);
					# print "Equations:\n$eq_mat\n";
					# print "IP: $interior_point\n";
					my $test = $eq_mat->rows;
					if($test == 0){
						# print "ok\n";
						push @relevant, $C;
					} else {
						my $zero = zero_vector<Rational>($test);
						my @good_rays = grep($eq_mat * $tvr->[$_] == $zero, @$C);
						# print "good rays: @good_rays\n";
						push @relevant, new Set<Integer>(@good_rays);
					}
					last;
				}
			}
			#print "la\n";	
		}
		$this->RELEVANT_CONES = check_fan($tvr, new Array< Set<Integer>>(@relevant));
	}


	rule TROPICAL_FAN : EQUATION {
		$this->TROPICAL_FAN = gfan_tropicalhypersurface($this->EQUATION);
	}

	

}

# This program preprocesses the input for gfan and then reads in the gfan output.
# It should be checked whether gfan_groebnerbla can really be left out.
sub gfan_tropicalbruteforce {
	my ($coefficients, $exponents) = @_;
	my $tempfile=new Tempfile;
	#my $tempfile="test";
	
	# Homogenizing polynomial and preparing to write to file:	
	my $nvars = $exponents->cols();
	my @vars = ( "t" , map { "x$_" } (1..$nvars) );
	my $one = ones_vector<Int>($nvars);
	my $degrees = $exponents*$one;
	my $homog = new Matrix<Int>[[map{maximum($degrees)-$degrees->[$_]} (0..($exponents->rows()-1))]];
	print $homog;
	my $newexp = transpose($homog)|$exponents;
	my $R = new Ring(@vars);
	my $p = new Polynomial($newexp,$coefficients,$R); 
	
	# Writing data to file:
	open(my $input, ">$tempfile.in") or die "Can't create temporary file $tempfile.in: $!";
	print $input "Q[";
	print $input join(",",$R->variables);
	print $input "]{\n";
	print $input $p;
	print $input "\n}";
	print $tempfile;
	close $input;
	
	# Accessing gfan:
	system "$gfan_tropicalbruteforce --xml <$tempfile.in >$tempfile.poly 2>/dev/null";
	
	my $gfan_out= User::load("$tempfile.poly");
	return $gfan_out;
}

# This program preprocesses the input for gfan and then reads in the gfan output.
# It should be checked whether gfan_groebnerbla can really be left out.
sub gfan_tropicalhypersurface {
	my ($g) = @_;
	my $tempfile=new Tempfile;
	#my $tempfile="test";
	
	# Homogenizing polynomial and preparing to write to file:	
	my $R = $g->get_ring;
	
	# Writing data to file:
	open(my $input, ">$tempfile.in") or die "Can't create temporary file $tempfile.in: $!";
	print $input "Q[";
	print $input join(",",$R->variables);
	print $input "]{\n";
	print $input $g;
	print $input "\n}";
	print $tempfile;
	close $input;
	
	# print "$gfan_tropicalhypersurface\nlala\n$gfan_tropicalbruteforce\nlala\n";
	# Accessing gfan:
	system "$gfan_tropicalhypersurface --xml <$tempfile.in >$tempfile.poly 2>/dev/null";
	
	my $gfan_out= User::load("$tempfile.poly");
	return check_fan(-$gfan_out->RAYS, $gfan_out->MAXIMAL_CONES);
}

user_function add_ray(PolyhedralFan, Vector){
	my($fan, $ray) = @_;
	my $oldrays = $fan->RAYS;
	my $newrays = $oldrays / $ray;
	print $newrays;
	my $mc = $fan->MAXIMAL_CONES;
	for my $f (@$mc) {
		print "$f\n";
		my $gens = new Matrix<Rational>(@$oldrays[@$f]);
		print $gens;	
	}	
}

user_function cocoref_bruteforce(Matrix) {
	my($rays) = @_;
	my $dim = $rays->cols();
	my $m = $rays->rows();
	my @init_cones = all_subsets_of_k($dim, 0..($m)-1);
	@init_cones = map(new Set($_), @init_cones);
	# print @init_cones;
	@init_cones = map((new Matrix<Rational>(@$rays[@$_])), @init_cones);
	@init_cones = grep(rank($_) == $dim, @init_cones);
	foreach my $r (@$rays){
		@init_cones = grep {
			my $ina = inv($_);
			minimum($ina * $r) <= 0
		} @init_cones;
	}
	my $added = 1;

	@init_cones = map((new Cone<Rational>(INPUT_RAYS=>$_)), @init_cones);
	@init_cones = unique(@init_cones);
	my @refined = ();
	my @ti = @init_cones;
	while ($added == 1){
		$added = 0;
		my @next = ();
		foreach my $c (@ti){
			my @is = map(intersection($c, $_), @init_cones);
			@is = grep($_->DIM == $dim, @is);
			@is = grep(!included_polyhedra($c, $_), @is);
			my $keep = @is;
			if($keep == 0){
				push @refined, $c;
				my $ref = @refined;
				print "Pushed something. $ref\n"	
			} else {
				$added = 1;
				my $size = @is;
				while ($size > 0){
					my $new = pop @is;
					my $dontadd = 0;
					foreach my $old (@next, @refined){
						if (equal_polyhedra($new, $old)){
							$dontadd = 1;
							last;
						}
					}
					if ($dontadd == 0){
						push @next, $new;
					}
					$size = @is;
				}
				
				my $add = @next;
				print "Added something. $add\n";
			}
		}
		@ti = @next;
		my $a = @ti;
		print "Ending inner loop. $a\n\n";
	}
	@refined = unique(@refined);
	my $in = @refined;
	
	print "Number of resulting cones: $in.\n";
	return check_fan_objects(@refined);
}

sub mincones {
	my (@cones) = @_;
	my @result = ();
	my $c = @cones;
	while ($c > 0){
		my $cone = pop @cones;
		my @cj = ();
		my $min = 1;
		foreach my $D (@cones){
			if(included_polyhedra($D, $cone)){
				$min = 0;
				last;
			} elsif (!included_polyhedra($cone, $D)) {
				push @cj, $D;
			}
		}
		if ($min == 1){
			push @result, $cone;
		}
		@cones = @cj;
		$c = @cones;
		print "$c\n";
	}
	return @result;
}

sub unique {
	my (@cones) = @_;
	my @result = ();
	my $n = @cones;
	while($n>0){
		my $c = pop @cones;
		@cones = grep(!equal_polyhedra($c, $_), @cones);
		push @result, $c;
		$n = @cones;
	}
	return @result;
}

sub homogenize { 
	my ($in) = @_;
	
}

sub gale_dual{
	# TODO
	return 0;
}

user_function chow_quotient(Polynomial){
	my ($g) = @_;
	print "Defining Polynomial:\n$g\n\n";
	my $degs = dense($g->monomials_as_matrix);
	print "Exponents:\n$degs\n";
	my $coeffs = $g->coefficients_as_vector;
	print "Coefficients:\n$coeffs\n\n";
	my @r = @$degs;
	my $c = $r[0];
	#print $c;
	my @diffmatrows  = map($_-$c, @r);
	my $diffmat = new Matrix<Integer>(@diffmatrows);
	print "Pairwise differences:\n$diffmat\n";
	my $D = null_space($diffmat);
	print "D:\n$D\n";
	my $B = transpose(null_space($D));
	print "B:\n$B\n";
	# Test for exactness:
	# print $D*$B;
	my $deg_g = $D*$c;
	# Test for homogenoucity:
	# print "degree of g:\n$deg_g\n\n";
	# print $D*transpose(-$degs);
	my $dm1 = new Polytope<Rational>(EQUATIONS=>($deg_g | $D));
	my $a = $dm1->DIM;
	# Checking whether dimension is correct:
	# print "Dim:\n$a\n";
	my $zero = zero_vector($B->cols);
	my @fm = map(((ones_vector(1) | (-1)*(new Vector<Rational>($_)))/($zero | transpose(new Matrix<Rational>($B)))), @$degs);
	@fm = map((new Polytope<Rational>(POINTS=>$_)), @fm);
	my $good_points = $dm1;
	foreach my $P (@fm){
		$good_points = intersection($good_points, $P);
	}
	my $good_vert = $good_points->VERTICES->[0];
	# print $good_vert;
	my $par_vert = (cube($B->cols,0)->VERTICES)*($good_vert / ($zero |transpose(new Matrix<Rational>($B))));
	# print $par_vert;
	my $lat = (new Polytope<Rational>(POINTS=>$par_vert))->VERTICES;
	# print "\nOk lattice points:\n";
	my $p = -$lat->[0]->slice(1);
	# print "P: $p\n";
	my $test = new Matrix<Rational>(map($_-$p,@$degs));
	# print $test;
	# print $D*transpose($test);
	my @preim = map((new Polytope<Rational>(EQUATIONS=>(($p-$_) | new Matrix<Rational>($B))))->VERTICES, @$degs);
	# print @preim;
	my $new_degs = new Matrix<Int>(map($_->[0]->slice(1), @preim));
	# Building ring for output equation:
	my $nvars = $new_degs->cols;
	my @vars = ( map { "x$_" } (1..$nvars) );
	my $R = new Ring(@vars);
	my $g_tilda = new Polynomial($new_degs,$coeffs,$R); 
	print "g_tilda: $g_tilda\n";
	my $ambient_tv = cocoref_bruteforce(new Matrix<Rational>($B));
	return new HypersurfaceInTV(EQUATION=>$g_tilda, AMBIENT_TV=>cast<ToricVariety>($ambient_tv));
}

# Checking if a fan is complete by checking if every facet appears with an even factor.
user_function is_complete(PolyhedralFan<Rational>){
	my ($f) = @_;
	my $check = new Set<Cone<Rational>>();
	my $rays = new Matrix<Rational>($f->RAYS);
	# print $rays;
	my $mc = $f->MAXIMAL_CONES;
	# print $mc;
	foreach my $c (@$mc){
                my $A = new Cone<Rational>(INPUT_RAYS=>(new Matrix<Rational>(@$rays[@$c])));
		if($A->DIM < $A->AMBIENT_DIM){
			return (0==1);
		}
		my $F = $A->FACETS;
		# print $F;
		foreach my $f (@$F){
			# print "\n$f\n\n";
			my $sf = new Set<Cone<Rational>>(new Cone<Rational>(LINEALITY_SPACE=>$f));
			my $n = $check->size();
			$check = $check + $sf;
			if($n == $check->size){
				$check = $check - $sf;
			}
			# print "$check\n";
		}
	}
	print "$check\n";
	return ($check->size == 0);
}
